{% extends "base.html" %}

{% block title %}ë§¤í¬ë¡œ ì„¤ì •{% endblock %}

{% block body_class %}main-container{% endblock %}

{% block content %}
<div class="control-content">
    <!-- ë’¤ë¡œê°€ê¸° ë²„íŠ¼ê³¼ ì œëª© -->
    <div class="macro-header">
        <div class="back-button">
            <button onclick="location.href = '/main_settings'" class="macro-back-btn">â†</button>
         </div>
        <h1 class="macro-title-header">Macro ì„¤ì •</h1>
    </div>

    <!-- ë§¤í¬ë¡œ ì¹´ë“œ ê·¸ë¦¬ë“œ -->
    <div class="macro-setting-grid" id="macro-grid">
        <!-- ë§¤í¬ë¡œ ì¹´ë“œë“¤ì€ JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ìƒì„± -->
    </div>

    <!-- í•˜ë‹¨ ì•¡ì…˜ ë²„íŠ¼ë“¤ -->
    <div class="macro-setting-actions">
        <button class="action-btn rename-btn" onclick="openKeypad()" id="rename-btn" disabled>ì´ë¦„ë³€ê²½</button>
        <button class="action-btn save-btn" onclick="saveMacro()" id="save-btn" disabled>ì €ì¥</button>
    </div>
</div>

<!-- í‚¤íŒ¨ë“œ ëª¨ë‹¬ -->
<div class="keypad-modal" id="keypad-modal" style="display: none;">
    <div class="keypad-container">
        <div class="keypad-header">
            <button class="keypad-back-btn" onclick="closeKeypad()">â†</button>
            <div class="keypad-input-display">
                <input type="text" id="keypad-input" placeholder="ì—¬ê¸°ì— ë§¤í¬ë¡œ ì´ë¦„ì´ í‘œì‹œë©ë‹ˆë‹¤" maxlength="20" autocomplete="off" spellcheck="false">
            </div>
        </div>
        
        <div class="keypad-content">
            <div class="keypad-title">í•œê¸€ í‚¤íŒ¨ë“œ - í„°ì¹˜í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”</div>
            <div class="keypad-refresh-btn" onclick="clearInput()" title="ì…ë ¥ ì´ˆê¸°í™”">âŸ²</div>
            
            <div class="keypad-grid">
                <!-- í‚¤íŒ¨ë“œ ë²„íŠ¼ë“¤ì€ JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% include 'bottom_nav.html' %}

{% block extra_js %}
<script data-page-script>
(function() {
    'use strict';
    
    let selectedMacro = null;
    let macros = [];
    let isNewMacro = false;
    
    // ì‹¤ì œ ì €ì¥ëœ ë§¤í¬ë¡œì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
    function isRealMacro(macro) {
        // ê¸°ë³¸ ì²´í¬
        if (!macro || !macro.id || !macro.name) {
            return false;
        }
        
        // ë¹ˆ ì„¤ì •ê°’ì¸ ë§¤í¬ë¡œëŠ” ì„ì‹œ ë°ì´í„°ë¡œ ê°„ì£¼
        if (!macro.settings || Object.keys(macro.settings).length === 0) {
            console.log(`âš ï¸ ì €ì¥ë˜ì§€ ì•Šì€ ë§¤í¬ë¡œ ì œì™¸: "${macro.name}"`);
            return false;
        }
        
        return true;
    }

    // ë§¤í¬ë¡œ ë°ì´í„° ë¡œë“œ
    async function loadMacros() {
        try {
            console.log(' ë§¤í¬ë¡œ ì„¤ì • ë°ì´í„° ë¡œë“œ ì¤‘...');
            
            const response = await fetch('/api/macros');
            const data = await response.json();
            console.log(' ë§¤í¬ë¡œ ì„¤ì • API ì‘ë‹µ:', data);
            
            if (data && Array.isArray(data.macros)) {
                // ì‹¤ì œ ì €ì¥ëœ ë§¤í¬ë¡œë§Œ í•„í„°ë§ (settingsê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ê²ƒë§Œ)
                const realMacros = data.macros.filter(isRealMacro);
                console.log(` ì €ì¥ëœ ë§¤í¬ë¡œ ${realMacros.length}ê°œ ë¡œë“œ ì™„ë£Œ`);
                
                // 3ê°œ ìŠ¬ë¡¯ì— ë§ê²Œ ë°°ì—´ ì¬êµ¬ì„± (ë¹ˆ ìŠ¬ë¡¯ì€ null)
                macros = [];
                for (let i = 0; i < 3; i++) {
                    macros[i] = realMacros[i] || null;
                }
                
                // ë¡œë“œëœ ë§¤í¬ë¡œ ì •ë³´ ì¶œë ¥
                realMacros.forEach((macro, index) => {
                    console.log(` ìŠ¬ë¡¯ ${index + 1}: "${macro.name}" (ID: ${macro.id})`);
                });
                
                console.log(`ë§¤í¬ë¡œ ìŠ¬ë¡¯ ìƒíƒœ: [${macros.map((m, i) => m ? `"${m.name}"` : 'ë¹ˆìŠ¬ë¡¯').join(', ')}]`);
            } else {
                console.warn(' ë§¤í¬ë¡œ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤:', data);
                macros = [null, null, null]; // 3ê°œ ë¹ˆ ìŠ¬ë¡¯ìœ¼ë¡œ ì´ˆê¸°í™”
            }
            
            renderMacroGrid();
        } catch (error) {
            console.error('ë§¤í¬ë¡œ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error);
            macros = [null, null, null]; // ì‹¤íŒ¨ ì‹œ 3ê°œ ë¹ˆ ìŠ¬ë¡¯ìœ¼ë¡œ ì´ˆê¸°í™”
            renderMacroGrid();
        }
    }
    
    // ë§¤í¬ë¡œ ê·¸ë¦¬ë“œ ë Œë”ë§
    function renderMacroGrid() {
        const grid = document.getElementById('macro-grid');
        grid.innerHTML = '';
        
        for (let i = 0; i < 3; i++) {
            const macro = macros[i];
            const card = document.createElement('div');
            card.className = 'macro-setting-card';
            card.id = `macro-${i + 1}`;
            card.onclick = () => selectMacro(i + 1);
            
            if (macro) {
                // ê¸°ì¡´ ë§¤í¬ë¡œ
                card.innerHTML = `
                    <div class="macro-icon"></div>
                    <div class="macro-title">${macro.name}</div>
                `;
            } else {
                // ë¹ˆ ìŠ¬ë¡¯
                card.innerHTML = `
                    <div class="macro-icon empty">+</div>
                    <div class="macro-title">ë§¤í¬ë¡œ ë“±ë¡</div>
                `;
                card.classList.add('empty-slot');
            }
            
            grid.appendChild(card);
        }
    }
    
    // ë§¤í¬ë¡œ ì„ íƒ (ì‹œê°ì  íš¨ê³¼)
    window.selectMacro = function(macroId) {
        // ê¸°ì¡´ ì„ íƒ í•´ì œ (í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼)
        document.querySelectorAll('.macro-setting-card').forEach(card => {
            card.classList.remove('selected');
            card.style.transition = 'all 0.3s ease';
        });
        
        // ìƒˆë¡œìš´ ë§¤í¬ë¡œ ì„ íƒ (ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼)
        const selectedCard = document.getElementById(`macro-${macroId}`);
        if (selectedCard) {
            // ë¨¼ì € ì•½ê°„ì˜ ë”œë ˆì´ë¥¼ ì£¼ì–´ ì´ì „ ì„ íƒì´ í•´ì œë˜ë„ë¡ í•¨
            setTimeout(() => {
                selectedCard.classList.add('selected');
                selectedMacro = macroId;
                
                // ì„ íƒ íš¨ê³¼ ì‚¬ìš´ë“œ (ì„ íƒì‚¬í•­)
                // selectedCard.style.transform = 'scale(0.95)';
                // setTimeout(() => {
                //     selectedCard.style.transform = '';
                // }, 100);
                
                console.log(` Macro ${macroId} selected with animation`);
            }, 50);
        }
        
        // ë¹ˆ ìŠ¬ë¡¯ì¸ì§€ í™•ì¸
        const macro = macros[macroId - 1];
        isNewMacro = !macro;
        
        // ë²„íŠ¼ í™œì„±í™” (ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼)
        const renameBtn = document.getElementById('rename-btn');
        const saveBtn = document.getElementById('save-btn');
        
        // ë²„íŠ¼ë“¤ì„ ë¶€ë“œëŸ½ê²Œ í™œì„±í™”
        setTimeout(() => {
            renameBtn.disabled = false;
            saveBtn.disabled = false;
            
            // ë²„íŠ¼ í™œì„±í™” ì‹œê°ì  íš¨ê³¼
            renameBtn.style.transition = 'all 0.3s ease';
            saveBtn.style.transition = 'all 0.3s ease';
            renameBtn.style.opacity = '1';
            saveBtn.style.opacity = '1';
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
            renameBtn.textContent = isNewMacro ? 'ë§¤í¬ë¡œ ë“±ë¡' : 'ì´ë¦„ë³€ê²½';
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½ ì• ë‹ˆë©”ì´ì…˜
            renameBtn.style.transform = 'scale(1.05)';
            setTimeout(() => {
                renameBtn.style.transform = 'scale(1)';
            }, 150);
            
        }, 100);
        
        // ì„ íƒ í”¼ë“œë°± ë©”ì‹œì§€
        const cardTitle = selectedCard?.querySelector('.macro-title')?.textContent || `ë§¤í¬ë¡œ ${macroId}`;
        console.log(` "${cardTitle}" ${isNewMacro ? 'ë“±ë¡ ëª¨ë“œ' : 'ìˆ˜ì • ëª¨ë“œ'}ë¡œ ì„ íƒë¨`);
    };
    
    // í‚¤íŒ¨ë“œ ì—´ê¸°
    window.openKeypad = function() {
        if (!selectedMacro) return;
        
        const modal = document.getElementById('keypad-modal');
        const input = document.getElementById('keypad-input');
        
        // ê¸°ì¡´ ë§¤í¬ë¡œë©´ í˜„ì¬ ì´ë¦„ìœ¼ë¡œ ì´ˆê¸°í™”
        let initialValue = '';
        if (!isNewMacro) {
            const macro = macros[selectedMacro - 1];
            initialValue = macro ? macro.name : '';
        }
        
        // ê°•ë ¥í•œ ì´ˆê¸°ê°’ ì„¤ì •
        input.value = initialValue;
        input.setAttribute('value', initialValue);
        input.dataset.currentValue = initialValue;
        input.defaultValue = initialValue;
        
        // í™”ë©´ ì—…ë°ì´íŠ¸ ê°•ì œ
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
        
        // ìŠ¤íƒ€ì¼ ê°•ì œ ì ìš©
        input.style.color = '#000000';
        input.style.backgroundColor = '#ffffff';
        input.style.fontSize = '28px';
        input.style.border = '3px solid #007bff';
        input.style.display = 'block';
        input.style.opacity = '1';
        input.style.visibility = 'visible';
        
        console.log(`í‚¤íŒ¨ë“œ ì—´ê¸° - ì´ˆê¸°ê°’: "${initialValue}", ì„¤ì •ê°’: "${input.value}"`);
        
        // ì…ë ¥ í•„ë“œ ì†ì„± ì¬ì„¤ì •
        input.readOnly = false;
        input.disabled = false;
        
        modal.style.display = 'flex';
        
        // í‚¤íŒ¨ë“œ ë ˆì´ì•„ì›ƒ ì´ˆê¸°í™”
        updateKeypadLayout();
        
        // í¬ì»¤ìŠ¤ ì„¤ì • ë° ì»¤ì„œ ìœ„ì¹˜ ì¡°ì •
        setTimeout(() => {
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
            
            // ì…ë ¥ í•„ë“œ ìƒíƒœ ì™„ì „ ì²´í¬
            const computedStyle = window.getComputedStyle(input);
            console.log('=== í‚¤íŒ¨ë“œ ì—´ê¸° ì™„ë£Œ ===');
            console.log(`Value: "${input.value}"`);
            console.log(`Attribute: "${input.getAttribute('value')}"`);
            console.log(`Visible: ${input.offsetWidth > 0 && input.offsetHeight > 0}`);
            console.log(`Color: ${computedStyle.color}`);
            console.log(`Background: ${computedStyle.backgroundColor}`);
            console.log(`Font-size: ${computedStyle.fontSize}`);
            console.log(`Text-align: ${computedStyle.textAlign}`);
            console.log(`Language mode: ${keypadState.isKorean ? 'í•œê¸€' : 'ì˜ì–´'}`);
        }, 100);
        
        // ì…ë ¥ í•„ë“œ ê°•ì¡° íš¨ê³¼
        const inputDisplay = input.parentElement;
        inputDisplay.style.animation = 'pulse 0.5s ease-in-out';
        setTimeout(() => {
            inputDisplay.style.animation = '';
        }, 500);
    };
    
    // í‚¤íŒ¨ë“œ ë‹«ê¸°
    window.closeKeypad = function() {
        const modal = document.getElementById('keypad-modal');
        modal.style.display = 'none';
    };
    
    // í•œê¸€ ì¡°í•©ì„ ìœ„í•œ ìƒìˆ˜ë“¤
    const CHO_SUNG = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
    const JUNG_SUNG = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£'];
    const JONG_SUNG = ['','ã„±','ã„²','ã„³','ã„´','ã„µ','ã„¶','ã„·','ã„¹','ã„º','ã„»','ã„¼','ã„½','ã„¾','ã„¿','ã…€','ã…','ã…‚','ã…„','ã……','ã…†','ã…‡','ã…ˆ','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
    
    // ì¢…ì„±ì„ ì´ˆì„±ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë§µ (ë³µì¡í•œ ì¢…ì„± ì²˜ë¦¬ìš©)
    const JONG_TO_CHO = {
        'ã„±': 'ã„±', 'ã„²': 'ã„²', 'ã„´': 'ã„´', 'ã„·': 'ã„·', 'ã„¹': 'ã„¹', 'ã…': 'ã…', 
        'ã…‚': 'ã…‚', 'ã……': 'ã……', 'ã…†': 'ã…†', 'ã…‡': 'ã…‡', 'ã…ˆ': 'ã…ˆ', 'ã…Š': 'ã…Š', 
        'ã…‹': 'ã…‹', 'ã…Œ': 'ã…Œ', 'ã…': 'ã…', 'ã…': 'ã…',
        // ë³µì¡í•œ ì¢…ì„±ì€ ì²« ë²ˆì§¸ ììŒìœ¼ë¡œ ë³€í™˜
        'ã„³': 'ã„±', 'ã„µ': 'ã„´', 'ã„¶': 'ã„´', 'ã„º': 'ã„¹', 'ã„»': 'ã„¹', 'ã„¼': 'ã„¹', 
        'ã„½': 'ã„¹', 'ã„¾': 'ã„¹', 'ã„¿': 'ã„¹', 'ã…€': 'ã„¹', 'ã…„': 'ã…‚'
    };
    
    // í•œê¸€ì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
    function isHangul(char) {
        return /[ã„±-ã…ã…-ã…£ê°€-í£]/.test(char);
    }
    
    // ììŒì¸ì§€ í™•ì¸ (ìŒììŒ í¬í•¨)
    function isConsonant(char) {
        const allConsonants = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
        return allConsonants.includes(char) || CHO_SUNG.includes(char) || JONG_SUNG.includes(char);
    }
    
    // ëª¨ìŒì¸ì§€ í™•ì¸ (ë³µí•©ëª¨ìŒ í¬í•¨)
    function isVowel(char) {
        const allVowels = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£'];
        return allVowels.includes(char) || JUNG_SUNG.includes(char);
    }
    
    // ì™„ì„±ëœ í•œê¸€ì¸ì§€ í™•ì¸ (ê°€-í£)
    function isCompleteHangul(char) {
        return /[ê°€-í£]/.test(char);
    }
    
    // í•œê¸€ì„ ì´ˆì„±, ì¤‘ì„±, ì¢…ì„±ìœ¼ë¡œ ë¶„í•´
    function decomposeHangul(char) {
        if (!isCompleteHangul(char)) return null;
        
        const charCode = char.charCodeAt(0) - 0xAC00;
        const jong = charCode % 28;
        const jung = (charCode - jong) / 28 % 21;
        const cho = ((charCode - jong) / 28 - jung) / 21;
        
        return {
            cho: CHO_SUNG[cho],
            jung: JUNG_SUNG[jung],
            jong: jong > 0 ? JONG_SUNG[jong] : ''
        };
    }
    
    // ì´ˆì„±, ì¤‘ì„±, ì¢…ì„±ìœ¼ë¡œ í•œê¸€ ì¡°í•©
    function composeHangul(cho, jung, jong = '') {
        const choIndex = CHO_SUNG.indexOf(cho);
        const jungIndex = JUNG_SUNG.indexOf(jung);
        const jongIndex = JONG_SUNG.indexOf(jong);
        
        if (choIndex === -1 || jungIndex === -1 || jongIndex === -1) {
            console.log(`ì¡°í•© ì‹¤íŒ¨: ì´ˆì„±="${cho}", ì¤‘ì„±="${jung}", ì¢…ì„±="${jong}"`);
            return null;
        }
        
        const charCode = 0xAC00 + (choIndex * 21 + jungIndex) * 28 + jongIndex;
        const result = String.fromCharCode(charCode);
        return result;
    }
    
    // ë³µí•© ëª¨ìŒ ì¡°í•© ë§µ
    const COMPLEX_VOWELS = {
        'ã…—ã…': 'ã…˜', 'ã…—ã…': 'ã…™', 'ã…—ã…£': 'ã…š',
        'ã…œã…“': 'ã…', 'ã…œã…”': 'ã…', 'ã…œã…£': 'ã…Ÿ',
        'ã…¡ã…£': 'ã…¢',
        'ã…‘ã…£': 'ã…’', 'ã…•ã…£': 'ã…–'  // ì¶”ê°€ëœ ë³µí•©ëª¨ìŒ
    };

    // í•œê¸€ ì¡°í•© ì²˜ë¦¬
    function processHangulInput(currentText, newChar) {
        console.log(`ì¡°í•©: "${currentText}" + "${newChar}"`);
        
        if (!isHangul(newChar)) {
            return currentText + newChar;
        }
        
        if (currentText.length === 0) {
            return newChar;
        }
        
        const lastChar = currentText[currentText.length - 1];
        const beforeText = currentText.slice(0, -1);
        
        // ë§ˆì§€ë§‰ ë¬¸ìê°€ ì™„ì„±ëœ í•œê¸€ì¸ ê²½ìš°
        if (isCompleteHangul(lastChar)) {
            const decomposed = decomposeHangul(lastChar);
            
            // ìƒˆ ë¬¸ìê°€ ììŒì´ê³ , ë§ˆì§€ë§‰ ë¬¸ìì˜ ì¢…ì„±ì´ ì—†ëŠ” ê²½ìš° â†’ ì¢…ì„± ì¶”ê°€ ì‹œë„
            if (isConsonant(newChar) && !decomposed.jong) {
                // í•´ë‹¹ ììŒì´ ì¢…ì„±ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
                const jongIndex = JONG_SUNG.indexOf(newChar);
                if (jongIndex > 0) { // 0ì€ ë¹ˆ ì¢…ì„±ì´ë¯€ë¡œ > 0ìœ¼ë¡œ ì²´í¬
                    const composed = composeHangul(decomposed.cho, decomposed.jung, newChar);
                    if (composed) {
                        console.log(`ì¢…ì„± ì¶”ê°€: "${lastChar}" + "${newChar}" = "${composed}"`);
                        return beforeText + composed;
                    }
                }
            }
            
            // ìƒˆ ë¬¸ìê°€ ëª¨ìŒì¸ ê²½ìš°
            if (isVowel(newChar)) {
                // ì¢…ì„±ì´ ì—† ëŠ” ê²½ìš°: ë³µí•© ëª¨ìŒ ì‹œë„
                if (!decomposed.jong) {
                    const complexVowel = COMPLEX_VOWELS[decomposed.jung + newChar];
                    if (complexVowel) {
                        const composed = composeHangul(decomposed.cho, complexVowel);
                        if (composed) {
                            console.log(`ë³µí•© ëª¨ìŒ: "${lastChar}" + "${newChar}" = "${composed}"`);
                            return beforeText + composed;
                        }
                    }
                }
                
                // ë³µí•© ëª¨ìŒì´ ì•ˆë˜ê±°ë‚˜ ì¢…ì„±ì´ ìˆëŠ” ê²½ìš°: ìƒˆë¡œìš´ ê¸€ì ì‹œì‘
                // ì¢…ì„±ì„ ì´ˆì„±ìœ¼ë¡œ ì˜®ê¸°ê¸° ì‹œë„
                if (decomposed.jong) {
                    const newChoSung = JONG_TO_CHO[decomposed.jong];
                    if (newChoSung) {
                        const newChar1 = composeHangul(decomposed.cho, decomposed.jung, ''); // ì¢…ì„± ì œê±°
                        const newChar2 = composeHangul(newChoSung, newChar, ''); // ì¢…ì„±+ëª¨ìŒìœ¼ë¡œ ìƒˆ ê¸€ì
                        if (newChar1 && newChar2) {
                            console.log(`ì¢…ì„± ë¶„ë¦¬: "${lastChar}" + "${newChar}" = "${newChar1}${newChar2}"`);
                            return beforeText + newChar1 + newChar2;
                        }
                    }
                }
            }
            
            // ê·¸ ì™¸ì˜ ê²½ìš°ëŠ” ìƒˆë¡œìš´ ë¬¸ìë¡œ ì‹œì‘
            console.log(`ìƒˆ ê¸€ì ì‹œì‘: "${currentText}" + "${newChar}"`);
            return currentText + newChar;
        }
        
        // ë§ˆì§€ë§‰ ë¬¸ìê°€ ììŒì¸ ê²½ìš°
        if (isConsonant(lastChar)) {
            if (isVowel(newChar)) {
                const composed = composeHangul(lastChar, newChar);
                if (composed) {
                    console.log(`ììŒ+ëª¨ìŒ: "${lastChar}" + "${newChar}" = "${composed}"`);
                    return beforeText + composed;
                }
            }
            return currentText + newChar;
        }
        
        // ë§ˆì§€ë§‰ ë¬¸ìê°€ ëª¨ìŒì¸ ê²½ìš°
        if (isVowel(lastChar)) {
            // ë³µí•© ëª¨ìŒ ì¡°í•© ì‹œë„
            const complexVowel = COMPLEX_VOWELS[lastChar + newChar];
            if (complexVowel && isVowel(newChar)) {
                console.log(`ë³µí•© ëª¨ìŒ: "${lastChar}" + "${newChar}" = "${complexVowel}"`);
                return beforeText + complexVowel;
            }
        }
        
        return currentText + newChar;
    }

    // í‚¤íŒ¨ë“œ ë¬¸ì ì…ë ¥ (í•œê¸€ ì¡°í•© í¬í•¨)
    window.inputChar = function(char) {
        try {
            const input = document.getElementById('keypad-input');
            if (!input) {
                console.error('Input element not found');
                return;
            }
            
            if (input.value.length >= 20) {
                console.log('Maximum length reached');
                return;
            }
            
            const currentValue = input.value || '';
            let newValue;
            
            // í•œê¸€ ëª¨ë“œì—ì„œë§Œ í•œê¸€ ì¡°í•© ì²˜ë¦¬
            if (keypadState.isKorean && isHangul(char)) {
                newValue = processHangulInput(currentValue, char);
                console.log(`í•œê¸€ ì¡°í•©: "${currentValue}" + "${char}" = "${newValue}"`);
            } else {
                // ì˜ì–´/íŠ¹ìˆ˜ë¬¸ìëŠ” ë‹¨ìˆœ ì¶”ê°€
                newValue = currentValue + char;
                console.log(`ë‹¨ìˆœ ì¶”ê°€: "${currentValue}" + "${char}" = "${newValue}"`);
                
                // ì˜ì–´ ëª¨ë“œì—ì„œë§Œ ë¬¸ì ì…ë ¥ í›„ Shift ìë™ í•´ì œ (í•œê¸€ì€ ìˆ˜ë™ í•´ì œ)
                if (!keypadState.isKorean && keypadState.isShift && /[a-zA-Z]/.test(char)) {
                    keypadState.isShift = false;
                    setTimeout(() => {
                        updateKeypadLayout();
                        updateToggleButtonStyles();
                    }, 50);
                    console.log('ì˜ì–´ ì…ë ¥ í›„ Shift ìë™ í•´ì œ');
                }
                
                // í•œê¸€ ëª¨ë“œì—ì„œëŠ” ì‰¬í”„íŠ¸ ìƒíƒœ ìœ ì§€ (ìˆ˜ë™ìœ¼ë¡œë§Œ í•´ì œ)
            }
            
            // ê°•ë ¥í•œ ê°’ ì„¤ì • - ëª¨ë“  ë°©ë²• ì‹œë„
            input.value = newValue;
            input.setAttribute('value', newValue);
            input.dataset.currentValue = newValue;
            input.defaultValue = newValue;
            
            // ë¸Œë¼ìš°ì € í™”ë©´ ê°•ì œ ì—…ë°ì´íŠ¸ - ì—¬ëŸ¬ ë°©ë²• ì‹œë„
            input.dispatchEvent(new Event('input', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
            
            // ê°•ì œ ë¦¬ë Œë”ë§
            input.style.display = 'none';
            input.offsetHeight; // ê°•ì œ ë¦¬í”Œë¡œìš° 
            input.style.display = 'block';
            
            // ìŠ¤íƒ€ì¼ ê°•ì œ ì ìš©
            input.style.color = '#000000';
            input.style.backgroundColor = '#ffffff';
            input.style.fontSize = '28px';
            input.style.border = '3px solid #007bff';
            
            // ìƒì„¸í•œ ë””ë²„ê¹…ìš© ë¡œê·¸
            setTimeout(() => {
                const rect = input.getBoundingClientRect();
                const computed = window.getComputedStyle(input);
                console.log('=== ì…ë ¥ í›„ ìƒíƒœ í™•ì¸ ===');
                console.log(`Value: "${input.value}"`);
                console.log(`Attribute: "${input.getAttribute('value')}"`);
                console.log(`defaultValue: "${input.defaultValue}"`);
                console.log(`Visible: ${input.offsetWidth > 0 && input.offsetHeight > 0}`);
                console.log(`Position: x=${rect.x}, y=${rect.y}, w=${rect.width}, h=${rect.height}`);
                console.log(`Computed color: ${computed.color}`);
                console.log(`Computed background: ${computed.backgroundColor}`);
                console.log(`Computed display: ${computed.display}`);
                console.log(`Computed z-index: ${computed.zIndex}`);
                console.log(`Focus: ${document.activeElement === input}`);
            }, 50);
            
            // ì…ë ¥ ì‹œê°ì  í”¼ë“œë°±
            input.classList.add('typing');
            setTimeout(() => {
                input.classList.remove('typing');
            }, 200);
            
            // í¬ì»¤ìŠ¤ ìœ ì§€
            if (document.activeElement !== input) {
                input.focus();
            }
            
            console.log(`Added char: "${char}", Mode: ${keypadState.isKorean ? 'í•œê¸€' : 'ì˜ì–´'}, Current value: "${input.value}"`);
        } catch (error) {
            console.error('Error in inputChar:', error);
        }
    };
    
    // í‚¤íŒ¨ë“œ ìƒíƒœ ê´€ë¦¬
    let keypadState = {
        isKorean: true,    // í•œê¸€/ì˜ì–´ ëª¨ë“œ
        isShift: false,    // ì‰¬í”„íŠ¸ ìƒíƒœ 
        isSymbol: false    // íŠ¹ìˆ˜ë¬¸ì ëª¨ë“œ
    };
    
    // ì˜ì–´ QWERTY ë ˆì´ì•„ì›ƒ
    const QWERTY_LAYOUT = {
        normal: [
            ['q','w','e','r','t','y','u','i','o','p'],
            ['a','s','d','f','g','h','j','k','l'],
            ['z','x','c','v','b','n','m']
        ],
        shift: [
            ['Q','W','E','R','T','Y','U','I','O','P'],
            ['A','S','D','F','G','H','J','K','L'],
            ['Z','X','C','V','B','N','M']
        ]
    };
    
    // íŠ¹ìˆ˜ë¬¸ì ë ˆì´ì•„ì›ƒ
    const SYMBOL_LAYOUT = [
        ['!','@','#','$','%','^','&','*','(',')'],
        ['1','2','3','4','5','6','7','8','9','0'],
        ['-','=','[',']','\\',';','\'','`'],
        [',','.','/','~','_','+','{','}','|']
    ];

    // í•œì˜ ì „í™˜ (ê¸°ì¡´ í•¨ìˆ˜ - í˜¸í™˜ì„± ìœ ì§€)
    window.toggleLang = function() {
        switchKeypadMode(); // ìƒˆë¡œìš´ í•¨ìˆ˜ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
    };
    
    // ì‰¬í”„íŠ¸ ì „í™˜
    window.toggleShift = function() {
        keypadState.isShift = !keypadState.isShift;
        updateKeypadLayout();
        updateToggleButtonStyles();
        console.log(`ì‰¬í”„íŠ¸: ${keypadState.isShift ? 'ON' : 'OFF'}`);
    };
    
    // íŠ¹ìˆ˜ë¬¸ì ëª¨ë“œ ì „í™˜
    window.toggleSymbol = function() {
        keypadState.isSymbol = !keypadState.isSymbol;
        keypadState.isShift = false; // ì‰¬í”„íŠ¸ í•´ì œ
        updateKeypadLayout();
        updateToggleButtonStyles();
        console.log(`íŠ¹ìˆ˜ë¬¸ì ëª¨ë“œ: ${keypadState.isSymbol ? 'ON' : 'OFF'}`);
    };
    
    // í‚¤íŒ¨ë“œ ëª¨ë“œ ì „í™˜ (í•œê¸€ â†” ì˜ì–´)
    window.switchKeypadMode = function() {
        keypadState.isKorean = !keypadState.isKorean;
        keypadState.isSymbol = false; // íŠ¹ìˆ˜ë¬¸ì ëª¨ë“œ í•´ì œ
        keypadState.isShift = false; // ì‰¬í”„íŠ¸ í•´ì œ
        updateKeypadLayout();
        updateToggleButtonStyles();
        console.log(`í‚¤íŒ¨ë“œ ëª¨ë“œ ì „í™˜: ${keypadState.isKorean ? 'í•œê¸€' : 'ì˜ì–´'}`);
    };
    
    // í‚¤íŒ¨ë“œ ë ˆì´ì•„ì›ƒ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ ë²„ì „)
    function updateKeypadLayout() {
        const keypadGrid = document.querySelector('.keypad-grid');
        if (!keypadGrid) return;
        
        keypadGrid.innerHTML = '';
        
        if (keypadState.isSymbol) {
            // íŠ¹ìˆ˜ë¬¸ì ëª¨ë“œ
            renderSymbolLayout(keypadGrid);
        } else if (keypadState.isKorean) {
            // í•œê¸€ ëª¨ë“œ
            renderKoreanLayout(keypadGrid);
        } else {
            // ì˜ì–´ ëª¨ë“œ
            renderEnglishLayout(keypadGrid);
        }
        
        updateToggleButtonStyles();
    }
    
    // ë³µí•© íŠ¹ìˆ˜ë¬¸ì ì…ë ¥ í•¨ìˆ˜
    window.insertCompoundSymbol = function() {
        // #+= ë²„íŠ¼ì„ í´ë¦­í–ˆì„ ë•Œ # ì…ë ¥ (ê¸°ë³¸ ë™ì‘)
        inputChar('#');
    };
    
    // í•œê¸€ í‚¤ë³´ë“œ ë ˆì´ì•„ì›ƒ ì •ì˜ (ì´ë¯¸ì§€ ì°¸ê³ í•œ ì§ê´€ì  ë°°ì¹˜)
    const KOREAN_LAYOUT = {
        normal: {
            // ì§ê´€ì ì¸ í•œê¸€ í‚¤ë³´ë“œ ë°°ì¹˜
            row1: ['ã…‚','ã…ˆ','ã„·','ã„±','ã……','ã…›','ã…•','ã…‘','ã…','ã…”'],
            row2: ['ã…','ã„´','ã…‡','ã„¹','ã…','ã…—','ã…“','ã…','ã…£'],
            row3: ['ã…‹','ã…Œ','ã…Š','ã…','ã… ','ã…œ','ã…¡']
        },
        shift: {
            // Shift + í•œê¸€ (ìŒììŒ, ë³µí•©ëª¨ìŒ)
            row1: ['ã…ƒ','ã…‰','ã„¸','ã„²','ã…†','ã…›','ã…•','ã…‘','ã…’','ã…–'],
            row2: ['ã…','ã„´','ã…‡','ã„¹','ã…','ã…—','ã…“','ã…','ã…£'],
            row3: ['ã…‹','ã…Œ','ã…Š','ã…','ã… ','ã…œ','ã…¡']
        }
    };

    // í•œê¸€ ë ˆì´ì•„ì›ƒ ë Œë”ë§ (ì´ë¯¸ì§€ ê¸°ë°˜ 4ì¤„ êµ¬ì¡°)
    function renderKoreanLayout(container) {
        const currentLayout = keypadState.isShift ? KOREAN_LAYOUT.shift : KOREAN_LAYOUT.normal;
        
        let layout = `
            <!-- ì²« ë²ˆì§¸ ì¤„: ììŒ + ëª¨ìŒ (ì²« ë²ˆì§¸ í–‰) - 10ê°œ -->
        `;
        
        // ì²« ë²ˆì§¸ ì¤„: ììŒ + ëª¨ìŒ (ì²« ë²ˆì§¸ í–‰) - 10ê°œ
        currentLayout.row1.forEach(char => {
            const btnClass = isConsonant(char) ? 'consonant' : 'vowel';
            const shiftClass = keypadState.isShift ? ' shifted' : '';
            layout += `<button class="keypad-btn ${btnClass}${shiftClass}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        // ë‘ ë²ˆì§¸ ì¤„: ììŒ + ëª¨ìŒ (ë‘ ë²ˆì§¸ í–‰) - 9ê°œ
        currentLayout.row2.forEach(char => {
            const btnClass = isConsonant(char) ? 'consonant' : 'vowel';
            const shiftClass = keypadState.isShift ? ' shifted' : '';
            layout += `<button class="keypad-btn ${btnClass}${shiftClass}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        // ì„¸ ë²ˆì§¸ ì¤„: Shift + ììŒ/ëª¨ìŒ + í•˜ì´í”ˆ + ë°±ìŠ¤í˜ì´ìŠ¤ - 10ê°œ
        const shiftBtnClass = keypadState.isShift ? 'shift active' : 'shift';
        layout += `<button class="keypad-btn special ${shiftBtnClass}" onclick="toggleShift()">â‡§</button>`;
        
        currentLayout.row3.forEach(char => {
            const btnClass = isConsonant(char) ? 'consonant' : 'vowel';
            const shiftClass = keypadState.isShift ? ' shifted' : '';
            layout += `<button class="keypad-btn ${btnClass}${shiftClass}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        layout += `
            <button class="keypad-btn special" onclick="inputChar('-')">-</button>
            <button class="keypad-btn special delete" onclick="backspace()">âŒ«</button>
        `;
        
        // ë„¤ ë²ˆì§¸ ì¤„: ê¸°ëŠ¥ ë²„íŠ¼ë“¤ (ì´ë¯¸ì§€ ê¸°ë°˜) - 4ê°œ
        layout += `
            <!-- í•˜ë‹¨ ê¸°ëŠ¥ ë²„íŠ¼ë“¤ -->
            <button class="keypad-btn special bottom-btn symbol-switch" onclick="toggleSymbol()">123</button>
            <button class="keypad-btn special bottom-btn lang-switch" onclick="switchKeypadMode()">ğŸŒ</button>
            <button class="keypad-btn special bottom-btn space-btn" onclick="inputChar(' ')">ìŠ¤í˜ì´ìŠ¤</button>
            <button class="keypad-btn special bottom-btn confirm-btn" onclick="confirmInput()">í™•ì¸</button>
        `;
        
        container.innerHTML = layout;
        
        console.log(`í•œê¸€ í‚¤íŒ¨ë“œ ë Œë”ë§ ì™„ë£Œ - Shift: ${keypadState.isShift ? 'ON' : 'OFF'}`);
    }
    
    // ì˜ì–´ ë ˆì´ì•„ì›ƒ ë Œë”ë§ (ì´ë¯¸ì§€ ê¸°ë°˜ QWERTY + 4ì¤„ êµ¬ì¡°)
    function renderEnglishLayout(container) {
        const letters = keypadState.isShift ? QWERTY_LAYOUT.shift : QWERTY_LAYOUT.normal;
        
        let layout = `
            <!-- ì²« ë²ˆì§¸ ì¤„: QWERTY ì²« í–‰ - 10ê°œ -->
        `;
        
        // QWERTY ì²« ë²ˆì§¸ í–‰ (q w e r t y u i o p) - 10ê°œ
        letters[0].forEach(char => {
            const isUpper = keypadState.isShift && char === char.toUpperCase();
            const className = `keypad-btn english ${isUpper ? 'uppercase' : ''}`;
            layout += `<button class="${className}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        // QWERTY ë‘ ë²ˆì§¸ í–‰ (a s d f g h j k l) - 9ê°œ
        letters[1].forEach(char => {
            const isUpper = keypadState.isShift && char === char.toUpperCase();
            const className = `keypad-btn english ${isUpper ? 'uppercase' : ''}`;
            layout += `<button class="${className}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        // ì„¸ ë²ˆì§¸ ì¤„: Shift + z x c v b n m + ë°±ìŠ¤í˜ì´ìŠ¤ - 10ê°œ
        const shiftBtnClass = keypadState.isShift ? 'shift active' : 'shift';
        layout += `<button class="keypad-btn special ${shiftBtnClass}" onclick="toggleShift()">â‡§</button>`;
        
        letters[2].forEach(char => {
            const isUpper = keypadState.isShift && char === char.toUpperCase();
            const className = `keypad-btn english ${isUpper ? 'uppercase' : ''}`;
            layout += `<button class="${className}" onclick="inputChar('${char}')">${char}</button>`;
        });
        
        layout += `<button class="keypad-btn special delete" onclick="backspace()">âŒ«</button>`;
        
        // ë„¤ ë²ˆì§¸ ì¤„: ê¸°ëŠ¥ ë²„íŠ¼ë“¤ (ì´ë¯¸ì§€ ê¸°ë°˜) - 4ê°œ
        layout += `
            <!-- í•˜ë‹¨ ê¸°ëŠ¥ ë²„íŠ¼ë“¤ -->
            <button class="keypad-btn special bottom-btn symbol-switch" onclick="toggleSymbol()">123</button>
            <button class="keypad-btn special bottom-btn lang-switch" onclick="switchKeypadMode()">ğŸŒ</button>
            <button class="keypad-btn special bottom-btn space-btn" onclick="inputChar(' ')">space</button>
            <button class="keypad-btn special bottom-btn confirm-btn" onclick="confirmInput()">return</button>
        `;
        
        container.innerHTML = layout;
        
        console.log(`ì˜ì–´ í‚¤íŒ¨ë“œ ë Œë”ë§ ì™„ë£Œ - Shift: ${keypadState.isShift ? 'ON' : 'OFF'}`);
    }
    
    // íŠ¹ìˆ˜ë¬¸ì ë ˆì´ì•„ì›ƒ ë Œë”ë§ (ì´ë¯¸ì§€ ê¸°ë°˜ 4ì¤„ êµ¬ì¡°)
    function renderSymbolLayout(container) {
        let layout = `
            <!-- ì²« ë²ˆì§¸ ì¤„: ìˆ«ì 1-0 -->
            <button class="keypad-btn number" onclick="inputChar('1')">1</button>
            <button class="keypad-btn number" onclick="inputChar('2')">2</button>
            <button class="keypad-btn number" onclick="inputChar('3')">3</button>
            <button class="keypad-btn number" onclick="inputChar('4')">4</button>
            <button class="keypad-btn number" onclick="inputChar('5')">5</button>
            <button class="keypad-btn number" onclick="inputChar('6')">6</button>
            <button class="keypad-btn number" onclick="inputChar('7')">7</button>
            <button class="keypad-btn number" onclick="inputChar('8')">8</button>
            <button class="keypad-btn number" onclick="inputChar('9')">9</button>
            <button class="keypad-btn number" onclick="inputChar('0')">0</button>
            
            <!-- ë‘ ë²ˆì§¸ ì¤„: ê¸°ë³¸ íŠ¹ìˆ˜ë¬¸ì - 10ê°œ -->
            <button class="keypad-btn special" onclick="inputChar('-')">-</button>
            <button class="keypad-btn special" onclick="inputChar('/')">/</button>
            <button class="keypad-btn special" onclick="inputChar(':')">:</button>
            <button class="keypad-btn special" onclick="inputChar(';')">;</button>
            <button class="keypad-btn special" onclick="inputChar('(')">(</button>
            <button class="keypad-btn special" onclick="inputChar(')')">)</button>
            <button class="keypad-btn special" onclick="inputChar('â‚©')">â‚©</button>
            <button class="keypad-btn special" onclick="inputChar('&')">&</button>
            <button class="keypad-btn special" onclick="inputChar('@')">@</button>
            <button class="keypad-btn special" onclick="inputChar('&quot;')">"</button>
            
            <!-- ì„¸ ë²ˆì§¸ ì¤„: ë³µí•© íŠ¹ìˆ˜ë¬¸ì + ì¶”ê°€ ê¸°í˜¸ + ë°±ìŠ¤í˜ì´ìŠ¤ - 10ê°œ -->
            <button class="keypad-btn special compound" onclick="insertCompoundSymbol()" title="# + =">#+= </button>
            <button class="keypad-btn special" onclick="inputChar('.')">.</button>
            <button class="keypad-btn special" onclick="inputChar(',')">,</button>
            <button class="keypad-btn special" onclick="inputChar('?')">?</button>
            <button class="keypad-btn special" onclick="inputChar('!')">!</button>
            <button class="keypad-btn special" onclick="inputChar('\\'')'">'</button>
            <button class="keypad-btn special" onclick="inputChar('#')">#</button>
            <button class="keypad-btn special" onclick="inputChar('+')" >+</button>
            <button class="keypad-btn special" onclick="inputChar('=')">=</button>
            <button class="keypad-btn special delete" onclick="backspace()">âŒ«</button>
            
            <!-- ë„¤ ë²ˆì§¸ ì¤„: ê¸°ëŠ¥ ë²„íŠ¼ë“¤ (ì´ë¯¸ì§€ ê¸°ë°˜) - 4ê°œ -->
            <button class="keypad-btn special bottom-btn symbol-switch" onclick="toggleSymbol()">ABC</button>
            <button class="keypad-btn special bottom-btn lang-switch" onclick="switchKeypadMode()">ğŸŒ</button>
            <button class="keypad-btn special bottom-btn space-btn" onclick="inputChar(' ')">space</button>
            <button class="keypad-btn special bottom-btn confirm-btn" onclick="confirmInput()">return</button>
        `;
        
        container.innerHTML = layout;
        
        console.log('íŠ¹ìˆ˜ë¬¸ì í‚¤íŒ¨ë“œ ë Œë”ë§ ì™„ë£Œ');
    }
    
    // í† ê¸€ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ (ìƒˆë¡œìš´ 4ì¤„ ë ˆì´ì•„ì›ƒ)
    function updateToggleButtonStyles() {
        setTimeout(() => {
            const shiftBtn = document.querySelector('.keypad-btn.shift');
            const langSwitchBtn = document.querySelector('.keypad-btn.lang-switch');
            const symbolSwitchBtn = document.querySelector('.keypad-btn.symbol-switch');
            const keypadTitle = document.querySelector('.keypad-title');
            
            // ê¸°ë³¸ ìƒíƒœë¡œ ë¦¬ì…‹
            [shiftBtn, langSwitchBtn, symbolSwitchBtn].forEach(btn => {
                if (btn) {
                    btn.classList.remove('active');
                    btn.style.backgroundColor = '';
                    btn.style.borderColor = '';
                }
            });
            
            // í‚¤íŒ¨ë“œ ì œëª© ì—…ë°ì´íŠ¸
            if (keypadTitle) {
                if (keypadState.isKorean) {
                    const shiftText = keypadState.isShift ? ' (ìŒììŒ/ë³µí•©ëª¨ìŒ)' : ' - í„°ì¹˜í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”';
                    keypadTitle.textContent = `í•œê¸€ í‚¤íŒ¨ë“œ${shiftText}`;
                } else if (keypadState.isSymbol) {
                    keypadTitle.textContent = 'íŠ¹ìˆ˜ë¬¸ì í‚¤íŒ¨ë“œ - ìˆ«ì ë° ê¸°í˜¸';
                } else {
                    keypadTitle.textContent = `ì˜ì–´ í‚¤íŒ¨ë“œ ${keypadState.isShift ? '(ëŒ€ë¬¸ì)' : '(ì†Œë¬¸ì)'}`;
                }
            }
            
            // Shift ë²„íŠ¼ í™œì„± ìƒíƒœ í‘œì‹œ
            if (keypadState.isShift && shiftBtn) {
                shiftBtn.classList.add('active');
                shiftBtn.style.backgroundColor = 'rgba(33, 150, 243, 0.4)';
                shiftBtn.style.borderColor = '#2196F3';
                shiftBtn.style.color = '#2196F3';
            }
            
            // í•œ/ì˜ ì „í™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸ (ğŸŒ)
            if (langSwitchBtn) {
                if (!keypadState.isKorean) {
                    langSwitchBtn.classList.add('active');
                    langSwitchBtn.style.backgroundColor = 'rgba(33, 150, 243, 0.4)';
                    langSwitchBtn.style.borderColor = '#2196F3';
                }
            }
            
            // 123/ABC ë²„íŠ¼ í™œì„± ìƒíƒœ í‘œì‹œ
            if (keypadState.isSymbol && symbolSwitchBtn) {
                symbolSwitchBtn.classList.add('active');
                symbolSwitchBtn.style.backgroundColor = 'rgba(156, 39, 176, 0.4)';
                symbolSwitchBtn.style.borderColor = '#9C27B0';
            }
        }, 10);
    }
    
    // ë³µí•© ëª¨ìŒ ë¶„í•´ ë§µ (ë°±ìŠ¤í˜ì´ìŠ¤ìš©)
    const COMPLEX_VOWEL_DECOMPOSE = {
        'ã…˜': 'ã…—', 'ã…™': 'ã…—', 'ã…š': 'ã…—',
        'ã…': 'ã…œ', 'ã…': 'ã…œ', 'ã…Ÿ': 'ã…œ',
        'ã…¢': 'ã…¡',
        'ã…’': 'ã…‘', 'ã…–': 'ã…•'  // ì¶”ê°€ëœ ë³µí•©ëª¨ìŒ ë¶„í•´
    };

    // í•œê¸€ ë°±ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬
    function processHangulBackspace(currentText) {
        if (currentText.length === 0) {
            return '';
        }
        
        const lastChar = currentText[currentText.length - 1];
        const beforeText = currentText.slice(0, -1);
        
        // ë§ˆì§€ë§‰ ë¬¸ìê°€ ì™„ì„±ëœ í•œê¸€ì¸ ê²½ìš°
        if (isCompleteHangul(lastChar)) {
            const decomposed = decomposeHangul(lastChar);
            
            if (decomposed.jong) {
                // ì¢…ì„±ì´ ìˆìœ¼ë©´ ì¢…ì„±ë§Œ ì œê±°
                const composed = composeHangul(decomposed.cho, decomposed.jung, '');
                return beforeText + composed;
            } else {
                // ë³µí•© ëª¨ìŒì¸ì§€ í™•ì¸
                const baseVowel = COMPLEX_VOWEL_DECOMPOSE[decomposed.jung];
                if (baseVowel) {
                    // ë³µí•© ëª¨ìŒì„ ê¸°ë³¸ ëª¨ìŒìœ¼ë¡œ ë¶„í•´
                    const composed = composeHangul(decomposed.cho, baseVowel, '');
                    return beforeText + composed;
                } else {
                    // ê¸°ë³¸ ëª¨ìŒì´ë©´ ì¤‘ì„± ì œê±°í•˜ê³  ì´ˆì„±ë§Œ ë‚¨ê¹€
                    return beforeText + decomposed.cho;
                }
            }
        }
        
        // ë§ˆì§€ë§‰ ë¬¸ìê°€ ë³µí•© ëª¨ìŒì¸ ê²½ìš°
        if (isVowel(lastChar)) {
            const baseVowel = COMPLEX_VOWEL_DECOMPOSE[lastChar];
            if (baseVowel) {
                return beforeText + baseVowel;
            }
        }
        
        // í•œê¸€ì´ ì•„ë‹ˆê±°ë‚˜ ì¡°í•©ë˜ì§€ ì•Šì€ ë¬¸ìëŠ” ê·¸ëƒ¥ ì œê±°
        return beforeText;
    }

    // ë°±ìŠ¤í˜ì´ìŠ¤
    window.backspace = function() {
        const input = document.getElementById('keypad-input');
        if (input) {
            const currentValue = input.value || '';
            const newValue = processHangulBackspace(currentValue);
            
            // ì•ˆì „í•œ ê°’ ì„¤ì •
            if (input.updateValueSafely) {
                input.updateValueSafely(newValue);
            } else {
                input.value = newValue;
                input.dataset.currentValue = newValue;
            }
            input.setAttribute('value', newValue);
            console.log(`Backspace, Current value: "${input.value}"`);
        }
    };
    
    // ì…ë ¥ ì´ˆê¸°í™”
    window.clearInput = function() {
        const input = document.getElementById('keypad-input');
        if (input) {
            // ì•ˆì „í•œ ê°’ ì„¤ì •
            if (input.updateValueSafely) {
                input.updateValueSafely('');
            } else {
                input.value = '';
                input.dataset.currentValue = '';
            }
            input.setAttribute('value', '');
            console.log('Input cleared');
        }
    };
    
    // ì…ë ¥ í™•ì¸ (ì„œë²„ ì €ì¥ í¬í•¨)
    window.confirmInput = async function() {
        const input = document.getElementById('keypad-input');
        const name = input.value.trim();
        
        console.log(`í™•ì¸ ë²„íŠ¼ í´ë¦­ - ì…ë ¥ê°’: "${name}"`);
        
        if (!name) {
            // ì…ë ¥ í•„ë“œ ê°•ì¡° (ë¹¨ê°„ìƒ‰)
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 8px rgba(244, 67, 54, 0.3)';
            setTimeout(() => {
                input.style.borderColor = '';
                input.style.boxShadow = '';
            }, 1500);
            
            alert('ë§¤í¬ë¡œ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            input.focus();
            return;
        }
        
        // ë¡œë”© ìƒíƒœ í‘œì‹œ
        input.style.borderColor = '#2196F3';
        input.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.3)';
        input.placeholder = 'ì €ì¥ ì¤‘...';
        input.disabled = true;
        
        try {
            // ë§¤í¬ë¡œ ì´ë¦„ ì—…ë°ì´íŠ¸
            const macro = macros[selectedMacro - 1];
            if (macro) {
                macro.name = name;
            } else {
                // ë¹ˆ ìŠ¬ë¡¯ì¸ ê²½ìš° ë§¤í¬ë¡œ ë°ì´í„° ìƒì„±
                macros[selectedMacro - 1] = {
                    id: selectedMacro,
                    name: name,
                    settings: {}
                };
            }
            
            // ì„œë²„ì— ì¦‰ì‹œ ì €ì¥
            const response = await fetch(`/api/macros/${selectedMacro}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: name,
                    settings: macros[selectedMacro - 1].settings || {}
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                // ì„±ê³µ í”¼ë“œë°± (ì´ˆë¡ìƒ‰)
                input.style.borderColor = '#4CAF50';
                input.style.boxShadow = '0 0 8px rgba(76, 175, 80, 0.3)';
                input.placeholder = 'ì €ì¥ ì™„ë£Œ!';
                
                // UI ì—…ë°ì´íŠ¸
                const selectedCard = document.getElementById(`macro-${selectedMacro}`);
                const titleElement = selectedCard.querySelector('.macro-title');
                titleElement.textContent = name;
                
                // ë¹ˆ ìŠ¬ë¡¯ì´ì—ˆë‹¤ë©´ ì¼ë°˜ ì¹´ë“œë¡œ ë³€ê²½
                if (isNewMacro) {
                    selectedCard.classList.remove('empty-slot');
                    const iconElement = selectedCard.querySelector('.macro-icon');
                    iconElement.classList.remove('empty');
                    iconElement.textContent = '';
                }
                
                console.log(`âœ… ë§¤í¬ë¡œ "${name}" ì €ì¥ ì™„ë£Œ!`);
                
                // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ (ì„ íƒì‚¬í•­)
                showSuccessMessage(`ë§¤í¬ë¡œ "${name}"ì´(ê°€) ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                
            } else {
                throw new Error(result.message || 'ì €ì¥ ì‹¤íŒ¨');
            }
            
        } catch (error) {
            console.error('ë§¤í¬ë¡œ ì €ì¥ ì‹¤íŒ¨:', error);
            
            // ì‹¤íŒ¨ í”¼ë“œë°± (ë¹¨ê°„ìƒ‰)
            input.style.borderColor = '#f44336';
            input.style.boxShadow = '0 0 8px rgba(244, 67, 54, 0.3)';
            input.placeholder = 'ì €ì¥ ì‹¤íŒ¨';
            
            alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            
            // ì›ë˜ ìƒíƒœë¡œ ë³µêµ¬
            setTimeout(() => {
                input.disabled = false;
                input.placeholder = 'ì—¬ê¸°ì— ë§¤í¬ë¡œ ì´ë¦„ì´ í‘œì‹œë©ë‹ˆë‹¤';
                input.style.borderColor = '';
                input.style.boxShadow = '';
                input.focus();
            }, 2000);
            return;
        }
        
        // ì„±ê³µ í›„ í‚¤íŒ¨ë“œ ë‹«ê¸°
        setTimeout(() => {
            closeKeypad();
            input.disabled = false;
            input.placeholder = 'ì—¬ê¸°ì— ë§¤í¬ë¡œ ì´ë¦„ì´ í‘œì‹œë©ë‹ˆë‹¤';
        }, 800);
    };
    
    // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜ (ê°œì„ ëœ ë²„ì „)
    function showSuccessMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.96);
            color: white;
            padding: 25px 35px;
            border-radius: 15px;
            font-family: 'Pretendard', sans-serif;
            font-size: 16px;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 400px;
            text-align: center;
            white-space: pre-line;
            line-height: 1.5;
            animation: successPopup 3s ease-in-out;
        `;
        
        // ë©”ì‹œì§€ íŒŒì‹± ë° ìŠ¤íƒ€ì¼ë§
        const lines = message.split('\n');
        let formattedHTML = '';
        
        lines.forEach((line, index) => {
            if (index === 0) {
                // ì²« ë²ˆì§¸ ì¤„ì€ ì œëª©ìœ¼ë¡œ ì²˜ë¦¬
                formattedHTML += `<div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; color: #fff;">${line}</div>`;
            } else if (line.trim().startsWith('-')) {
                // ë¦¬ìŠ¤íŠ¸ í•­ëª©
                formattedHTML += `<div style="text-align: left; margin: 5px 0; padding-left: 10px;">${line}</div>`;
            } else if (line.trim()) {
                // ì¼ë°˜ í…ìŠ¤íŠ¸
                formattedHTML += `<div style="margin: 8px 0;">${line}</div>`;
            } else {
                // ë¹ˆ ì¤„
                formattedHTML += '<div style="height: 10px;"></div>';
            }
        });
        
        messageDiv.innerHTML = formattedHTML;
        
        // CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
        const style = document.createElement('style');
        style.textContent = `
            @keyframes successPopup {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7) rotate(-5deg); }
                15% { opacity: 1; transform: translate(-50%, -50%) scale(1.05) rotate(2deg); }
                25% { opacity: 1; transform: translate(-50%, -50%) scale(0.98) rotate(0deg); }
                85% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(0deg); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8) rotate(0deg); }
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(messageDiv);
        
        // 3ì´ˆ í›„ ì œê±°
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 3000);
    }
    
    // ì €ì¥ ê¸°ëŠ¥ (ë§¤í¬ë¡œ ì´ë¦„ + í˜„ì¬ ê°œë³„ì œì–´ ì„¤ì •ê°’)
    window.saveMacro = async function() {
        if (!selectedMacro) {
            alert('ë§¤í¬ë¡œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
            return;
        }
        
        const macro = macros[selectedMacro - 1];
        if (!macro || !macro.name) {
            alert('ë§¤í¬ë¡œ ì´ë¦„ì„ ë¨¼ì € ì„¤ì •í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        // ì €ì¥ ë²„íŠ¼ ìƒíƒœ ë³€ê²½
        const saveBtn = document.getElementById('save-btn');
        const originalText = saveBtn.textContent;
        saveBtn.disabled = true;
        saveBtn.textContent = 'ì €ì¥ ì¤‘...';
        saveBtn.style.opacity = '0.6';
        
        try {
            console.log('ğŸ”„ í˜„ì¬ ì¡°ëª… ì„¤ì •ê°’ ê°€ì ¸ì˜¤ëŠ” ì¤‘...');
            
            // 1. í˜„ì¬ ì¡°ëª…/ê·¸ë£¹ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸°
            const settingsResponse = await fetch('/api/current-settings');
            const settingsResult = await settingsResponse.json();
            
            if (!settingsResult.success) {
                throw new Error('í˜„ì¬ ì„¤ì •ê°’ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + settingsResult.message);
            }
            
            console.log('âœ… í˜„ì¬ ì„¤ì •ê°’ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ:', settingsResult.settings);
            
            // 2. ë§¤í¬ë¡œ ë°ì´í„° êµ¬ì„± (ì´ë¦„ + í˜„ì¬ ì„¤ì •ê°’)
            const macroData = {
                name: macro.name,
                settings: {
                    ...settingsResult.settings,
                    saved_timestamp: new Date().toISOString(),
                    description: `${macro.name} - ${new Date().toLocaleString('ko-KR')}ì— ì €ì¥`
                }
            };
            
            console.log('ğŸ“ ì €ì¥í•  ë§¤í¬ë¡œ ë°ì´í„°:', macroData);
            
            // 3. ì„œë²„ì— ë§¤í¬ë¡œ ì €ì¥
            const response = await fetch(`/api/macros/${selectedMacro}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(macroData)
            });
            
            const result = await response.json();
            
            if (result.success) {
                // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
                macros[selectedMacro - 1].settings = macroData.settings;
                
                console.log(`âœ… ë§¤í¬ë¡œ "${macro.name}" ì €ì¥ ì™„ë£Œ!`);
                
                // ì„±ê³µ í”¼ë“œë°±
                saveBtn.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                saveBtn.style.borderColor = '#4CAF50';
                saveBtn.style.color = '#4CAF50';
                saveBtn.textContent = 'ì €ì¥ì™„ë£Œ!';
                
                // ìƒì„¸ ì„±ê³µ ë©”ì‹œì§€
                const groupCount = settingsResult.settings.groups?.length || 0;
                const lightCount = settingsResult.settings.lights?.length || 0;
                const successMsg = `ë§¤í¬ë¡œ "${macro.name}"ì´(ê°€) ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!\n\ní¬í•¨ëœ ì„¤ì •:\n- ê·¸ë£¹: ${groupCount}ê°œ\n- ê°œë³„ ì¡°ëª…: ${lightCount}ê°œ\n- ì €ì¥ ì‹œê°„: ${new Date().toLocaleString('ko-KR')}`;
                
                showSuccessMessage(successMsg);
                
                // 2ì´ˆ í›„ ì›ë˜ ìƒíƒœë¡œ ë³µì›
                setTimeout(() => {
                    saveBtn.style.backgroundColor = '';
                    saveBtn.style.borderColor = '';
                    saveBtn.style.color = '';
                    saveBtn.textContent = originalText;
                    saveBtn.style.opacity = '1';
                    saveBtn.disabled = false;
                }, 2000);
                
            } else {
                throw new Error(result.message || 'ì €ì¥ ì‹¤íŒ¨');
            }
            
        } catch (error) {
            console.error('âŒ ë§¤í¬ë¡œ ì €ì¥ ì‹¤íŒ¨:', error);
            
            // ì‹¤íŒ¨ í”¼ë“œë°±
            saveBtn.style.backgroundColor = 'rgba(244, 67, 54, 0.3)';
            saveBtn.style.borderColor = '#f44336';
            saveBtn.style.color = '#f44336';
            saveBtn.textContent = 'ì €ì¥ì‹¤íŒ¨';
            
            alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n' + error.message);
            
            // 2ì´ˆ í›„ ì›ë˜ ìƒíƒœë¡œ ë³µì›
            setTimeout(() => {
                saveBtn.style.backgroundColor = '';
                saveBtn.style.borderColor = '';
                saveBtn.style.color = '';
                saveBtn.textContent = originalText;
                saveBtn.style.opacity = '1';
                saveBtn.disabled = false;
            }, 2000);
        }
    };

    // í‚¤ë³´ë“œ ì…ë ¥ ë°©ì§€ ì„¤ì • (ë¶€ë“œëŸ½ê²Œ ê°œì„ )
    function setupInputBlocking() {
        const keypadInput = document.getElementById('keypad-input');
        if (keypadInput) {
            let isUpdatingValue = false;
            
            // ë¬¼ë¦¬ í‚¤ë³´ë“œ ì…ë ¥ë§Œ ì°¨ë‹¨ (í„°ì¹˜ ì…ë ¥ì€ í—ˆìš©)
            keypadInput.addEventListener('keydown', function(e) {
                if (!isUpdatingValue) {
                    e.preventDefault();
                    return false;
                }
            });
            
            keypadInput.addEventListener('keypress', function(e) {
                if (!isUpdatingValue) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // ë¶™ì—¬ë„£ê¸° ì°¨ë‹¨
            keypadInput.addEventListener('paste', function(e) {
                e.preventDefault();
                return false;
            });
            
            // ë” ì´ìƒ updateValueSafely í•¨ìˆ˜ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            // ì§ì ‘ì ì¸ ê°’ ì„¤ì •ë§Œ ì‚¬ìš©
            
            console.log('Input blocking setup complete');
        }
    }
    
    // ì´ˆê¸° ì„¤ì •
    setupInputBlocking();

    // í˜ì´ì§€ ì´ˆê¸°í™”
    loadMacros();
    console.log('Macro setting page initialized');
})();
</script>
{% endblock %} 